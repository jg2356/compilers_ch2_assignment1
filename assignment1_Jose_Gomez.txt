Author: Jose Gomez
Nova Southeastern University
May 17th 2015
CISC 630


2.2.1: Consider the context-free grammar:
S -> S S + | S S * | a

a) Show how the string aa+a* can be generated by this grammar.
s -> s S * -> s S + S * -> a s + S * -> a a + s * -> a a + a *

b) Construct a parse tree for this string.
           S
         / | \
        /  |  \
       /   |   \
      /    |    \
     S     S     *
    /|\    |     
   / | \   |      
  S  S  +  |        
  |  |     |     
  a  a     a     

c) What language does this grammar generate? Justify your answer. 
The language generated is a postfix expression consisting of: the term a, multiplication sign, plus sign.

2.2.2: What language is generated by the following grammars? In each case justify your answer.

a) S -> 0 S 1 | 0 1
The language generated is a sequence of the digit 0 repeated n times and the digit 1 repeated n times. For example 000000111111.

b) S -> + S S | - S S | a
The language generated is a prefix expression consisting of: plus sign, minus sign, and the term a.

c) S -> S ( S ) S | e
The language generated is a matched parenthesis expression, allowing every possible arrangement and nesting, and including e (empty).


d) S -> a S b S | b S a S | e
The language generated is a character sequence consisting of the same number of "a" and "b" arranged in arbitrary order, and including e (empty).

e) S -> a | S + S | S S | S * | ( S )
The language generated is a regular expression consisting of: the term a, matching parenthesis, the plus sign, the multiplication sign.

2.2.3: Which of the grammars in Exercise 2.2.2 are ambiguous?
The following grammars are ambiguous:
- c. S -> S ( S ) S | e
- d. S -> a S b S | b S a S | e
- e. S -> a | S + S | S S | S * | ( S )

2.3.1: Construct a syntax-directed translation scheme that translates arithmetic expressions from infix notation into prefix notation in which an operator appears before its operands; e.g. -xy is the prefix notation for x - y. Give annotated parse trees for the inputs 9-5+2 and 9-5*2. 

infix to prefix translation scheme:
expr -> {print('+')} expr + term
      | {print('-')} expr - term
      | term
term -> {print('*')} term * factor
      | {print('/')} term / factor
      | factor
factor -> {print(digit)} digit
        | ( expr )

2.4.1: Construct recursive-descent parsers, starting with the following grammars:
Program:
a) S -> + S S | - S S | a

void S() {
  switch (lookAhead(1)) {
    case "a":
      matchToken("a");
      break;
    case "-":
      matchToken("-");
      S();
      S();
      break;
    case "+":
      matchToken("+");
      S();
      S();
      break;
    default:
      error();
  }
}

b) S -> S ( S ) S | e

void S() {
  switch (lookAhead(1)) {
    case "(":
      matchToken("(");
      S();
      matchToken(")");
      S();
      break;
  }
}

c) 0 S 1 | 0 1

void S() {
  switch (lookAhead(1)) {
    case "0":
      matchToken("0");
      S();
      matchToken("1");
    case "1"
      break;
    default:
      error();
  }
}
